\capitulo{5}{Aspectos relevantes del desarrollo del proyecto}

Este capítulo recoge los aspectos más importantes del desarrollo del proyecto. Engloba la descripción de los componentes implementados, la justificación de las decisiones tomadas y la diferenciación de las fases del desarrollo.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Inicio del proyecto}

La idea del proyecto surgió a partir de mi familiaridad con el flujo de trabajo en locales de restauración y el potencial de escalabilidad detectado, permitiendo futuras ampliaciones como  la gestión de inventario o el análisis de costes, entre otros. Asimismo, el desarrollo se planteó como una oportunidad para consolidar las competencias adquiridas durante la carrera y profundizar en tecnologías modernas de alta demanda en el mercado actual.

En la primera reunión con el tutor, se le explicaron los objetivos generales y las funcionalidades mínimas que se pretendía que abarcara la aplicación. Se acordó entonces introducir aspectos que contribuyeran a la diferenciación de la aplicación respecto de herramientas comunes de gestión. Fue ahí donde el tutor propuso tomar como referencia un Trabajo de Fin de Grado anterior, elaborado por Álvaro Manjón Vara. En dicho proyecto se desarrolló una aplicación web de nombre \textit{\textbf{NutriMenu}}~\cite{nutrimenu2024}, dirigida a los centros de restauración de la Universidad de Burgos, cuya principal funcionalidad era la creación de menús con información nutricional de cada plato, obtenida a partir de una API externa.

Se dio la circunstancia de que el \textit{stack} tecnológico sugerido al tutor coincidía en gran medida con el del TFG mencionado. Aún así, no se optó por utilizar como base dicha aplicación, sino que se partió de un desarrollo desde cero, puesto que tanto el modelo de datos como la lógica de negocio iban a verse modificados significativamente y nuevos módulos de gestión iban a ser añadidos.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Desarrollo del \textit{backend}}

\subsection{Funcionalidades principales y módulos}

La API REST desarrollada cubre los principales procesos de gestión de un local de restauración, agrupados en los siguientes módulos funcionales:

{\small
\begin{itemize}
	\item \textbf{Gestión de pedidos (comandas):} soporta la creación y seguimiento de pedidos realizados en el local, diferenciando entre pedidos de barra y de comedor mediante una jerarquía de herencia.
	\item \textbf{Gestión de productos:} permite la creación, edición, consulta y eliminación de productos ofertados, así como la gestión de sus ingredientes y el cálculo dinámico de su información nutricional.
	\item \textbf{Gestión de alimentos e ingredientes:} facilita la administración de alimentos y su información nutricional, permitiendo su uso como ingredientes en productos.
	\item \textbf{Gestión de reservas de mesas:} permite la reserva y administración de mesas, incluyendo la gestión de disponibilidad y la prevención de solapamientos.
	\item \textbf{Gestión de mesas:} administra las mesas disponibles en el local, su capacidad y estado.
	\item \textbf{Gestión de usuarios:} administra las cuentas de acceso al sistema, permitiendo la asignación de roles específicos y el control de los datos personales del personal.
	\item \textbf{Gestión de roles:} define los perfiles de acceso mediante agrupaciones de permisos granulares, garantizando que cada usuario solo acceda a las funcionalidades autorizadas según su responsabilidad.
\end{itemize}}

Cada módulo está implementado siguiendo el patrón de capas descrito en la sección \textit{\ref{sec:4.2_arquitectura} \nameref{sec:4.2_arquitectura}}, lo que facilita la mantenibilidad y la extensibilidad del sistema.

%---------------------------------------------------------------

\subsection{Modelo de datos y relaciones}

El modelo de datos, específicamente en su módulo de alimentos, toma como referencia el esquema de \textit{NutriMenu}~\cite{nutrimenu2024}, el cual puede visualizarse por completo en la figura \ref{fig:5_modeloBD_nutrimenu}. Se utiliza una base de datos \textit{\textbf{MySQL}} para asegurar la consistencia relacional de la información. La persistencia se gestiona mediante repositorios que extienden de \texttt{JpaRepository}, lo que permite aprovechar las capacidades de \textit{Spring Data JPA} para la consulta y manipulación de datos. Al igual que en el proyecto de referencia, se emplea un \textbf{enfoque híbrido}, el cual combina el almacenamiento local de alimentos creados manualmente con la obtención de datos externos provenientes de la API de \textit{Open Food Facts}~\cite{api:openFoodFacts}.

\vspace{-8pt}
\imagenConEtiqueta[0.5\textwidth]{img/apdo_5/5_modeloBD_nutrimenu.png}{Modelo de base de datos de \textit{NutriMenu}~\cite{nutrimenu2024}}{5_modeloBD_nutrimenu}

A pesar de compartir el planteamiento conceptual con el proyecto de referencia, se han introducido \textbf{mejoras} significativas en la arquitectura de datos y la lógica de negocio para optimizar el \textbf{rendimiento} y la \textbf{mantenibilidad} del sistema. Las modificaciones más relevantes son:

\begin{itemize}
	\item \textbf{Simplificación mediante objetos embebidos:} a diferencia de \textit{NutriMenu}, que gestionaba la información nutricional (vitaminas, minerales, etc.) como entidades independientes, en este trabajo se han implementado como objetos embebidos (\texttt{\char`@{}Embeddable}). Esto elimina la necesidad de tablas adicionales y relaciones complejas (\textit{joins}), permitiendo que toda la información nutricional se persista en una única tabla de alimentos, lo que mejora la eficiencia de las operaciones en la base de datos.
	\item \textbf{Cálculo dinámico de información nutricional y consistencia:} se ha sustituido la actualización manual de valores nutricionales por un sistema de cálculo dinámico. Mientras que en el proyecto anterior los cálculos eran verbosos y se duplicaban en la base de datos, este modelo utiliza el principio \textit{``\textbf{Single Source of Truth}''}~\cite{medium:singleSourceTruth}, recalculando los valores en tiempo real a partir del alimento original. Esto asegura que cualquier cambio en un ingrediente se refleje automáticamente en todos los productos asociados.
	\item \textbf{Inclusión de información de alérgenos y métricas nutricionales por alimento:} se ha enriquecido el modelo mediante la integración de campos específicos para alérgenos y clasificaciones nutricionales estándar como \textit{Nutri-Score} y NOVA. Al aprovechar los datos proporcionados por la API de \textit{Open Food Facts}, el sistema ofrece una visión más profunda sobre la calidad y seguridad de los alimentos.%, permitiendo un filtrado y análisis que no era posible en el modelo de referencia.
\end{itemize}

\vspace{-15pt}
\imagenConEtiqueta[0.47\textwidth]{img/apen_C/C2_modeloEER_Completo.png}{Modelo de base de datos actual}{C2_modeloEER_Completo}

Para una descripción técnica más detallada sobre la implementación de estas entidades y la lógica de negocio aplicada, se recomienda consultar los \textit{pull requests} 
\href{https://github.com/aperezolmos/Orderly/pull/51}{\#51} y 
\href{https://github.com/aperezolmos/Orderly/pull/52}{\#52} 
en el repositorio del proyecto.

%---------------------------------------------------------------

\subsection{Lógica de negocio y servicios}

La lógica de negocio se encapsula en servicios específicos para cada módulo, que se encargan de validar las operaciones, gestionar las transacciones y aplicar las reglas del dominio. Por ejemplo:

\begin{itemize}
	\item El servicio de \textbf{productos} calcula la información nutricional total de cada producto en función de sus ingredientes, utilizando métodos de dominio y operaciones sobre objetos de tipo \texttt{NutritionInfo}.
	\item El servicio de \textbf{reservas} valida la disponibilidad de mesas y previene solapamientos mediante la comprobación de conflictos de horario antes de confirmar una reserva.
	\item El servicio de \textbf{pedidos} gestiona de forma transparente la creación y actualización de comandas, independientemente del tipo de pedido. Esto se logra mediante una jerarquía de entidades (\texttt{Order}, \texttt{BarOrder}, \texttt{DiningOrder}) y DTOs con herencia, combinada con una factoría de \textit{mappers} que selecciona dinámicamente la estrategia de conversión apropiada. Además, cada tipo de pedido dispone de un servicio y controlador específicos para consultas especializadas sobre las tablas hijas, optimizando el rendimiento al usar la estrategia \textit{joined inheritance}.
\end{itemize}

La separación de responsabilidades
%entre servicios y controladores 
permite mantener la lógica de negocio aislada de los puntos de entrada de la API, facilitando la reutilización y el testeo de los componentes. Este diseño ha favorecido la implementación de \textbf{controladores finos} (\textit{thin controllers}), esto es, controladores que se mantienen ligeros al delegar toda la complejidad y las reglas de dominio en los servicios correspondientes.

%---------------------------------------------------------------

\subsection{Comunicación entre capas: DTOs y \textit{mappers}}

La comunicación entre las distintas capas de la aplicación se realiza mediante objetos de transferencia de datos, diferenciando entre DTOs de \textbf{petición} (\textit{RequestDTO}) y de \textbf{respuesta} (\textit{ResponseDTO}). Esta distinción permite adaptar los datos expuestos por la API a las necesidades de cada operación, facilitando la validación de los datos recibidos (ver apartado \textit{\nameref{subsec:5.2_excepVal}}) y ocultando detalles internos o sensibles. Por ejemplo, la contraseña de un usuario, aunque se almacena encriptada, no se proporciona en el DTO de respuesta.

La conversión entre entidades y DTOs se realiza mediante \textit{mappers} implementados con \textit{MapStruct} (ver diagrama de comunicación en la figura \ref{fig:5.2_diagrama_dtoMapper}), lo que permite definir reglas de mapeo declarativas y reducir la cantidad de código repetitivo. En casos complejos, como la jerarquía de pedidos, se emplea una factoría de \textit{mappers} para aislar la lógica de conversión y facilitar la extensión a nuevos tipos de pedidos.

\imagenConEtiqueta[0.75\textwidth]{img/apdo_5/5.2_diagrama_dtoMapper.png}{Diagrama de comunicación entre capas}{5.2_diagrama_dtoMapper}

%---------------------------------------------------------------

\subsection{Seguridad y control de acceso}

La seguridad y el control de acceso en el \textit{backend} se gestionan mediante \textit{Spring Security}, implementando un sistema de autenticación basado en sesiones HTTP y \textbf{autorización granular por roles y permisos} 
(ver \textit{pull request} \href{https://github.com/aperezolmos/Orderly/pull/81}{\#81}). 
Los \textit{endpoints} de la API están protegidos mediante anotaciones \texttt{\char`@{}PreAuthorize}, que verifican los permisos necesarios para cada operación, garantizando que solo los usuarios autorizados puedan acceder a los recursos sensibles.

La gestión de la \textbf{autenticación} se centraliza en una capa de servicios que valida las credenciales y, tras un inicio de sesión o registro exitoso, vincula el contexto de seguridad a la sesión del usuario. Dicha sesión se mantiene de forma \textbf{persistente} en el \textit{backend} mediante el componente \texttt{HttpSessionSecurityContextRepository}, permitiendo que el sistema identifique al usuario en peticiones sucesivas a través de una \textit{cookie} de sesión (\texttt{JSESSIONID}). Para la representación de usuarios en el sistema de seguridad, se utiliza la clase \texttt{CustomUserDetails}, que adapta la entidad \texttt{User} y expone sus roles y permisos como \textit{authorities} de \textit{Spring Security}, permitiendo así un control de acceso detallado a los recursos.


%más breve
%La seguridad de la aplicación se gestiona mediante Spring Security, implementando control de acceso basado en roles y permisos. Los endpoints de la API están protegidos mediante anotaciones de autorización (\texttt{\char`@{}PreAuthorize}), y la autenticación se realiza mediante sesiones gestionadas en el backend. El sistema de roles y permisos permite una granularidad suficiente para cubrir los distintos perfiles de usuario del local.

%---------------------------------------------------------------

\subsection{Manejo de excepciones y validaciones}
\label{subsec:5.2_excepVal}

El \textit{backend} implementa un \textbf{sistema centralizado de manejo de excepciones} mediante el componente \texttt{GlobalExceptionHandler}, que captura y gestiona los errores más frecuentes (entidades no encontradas, violaciones de integridad, errores de validación, etc.). Los errores se devuelven en un formato estructurado que facilita su tratamiento en el \textit{frontend}.

\imagenConEtiqueta[0.75\textwidth]{img/apdo_5/5.2_error_response.png}{Ejemplos de errores de la API que utilizan el DTO \texttt{ErrorResponse}}{5.2_error_response}

Las validaciones de los datos de entrada se realizan tanto a nivel de DTOs, utilizando anotaciones estándar de \textit{Java Validation} (\texttt{\char`@{}NotNull}, \texttt{\char`@{}Size}, \texttt{\char`@{}Min}, etc.), como a nivel de lógica de negocio en los servicios. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Desarrollo del \textit{frontend}}

El desarrollo de la interfaz de usuario comenzó inicialmente con \textit{Thymeleaf}, integrado en el proyecto \textit{Spring Boot}, aprovechando la experiencia adquirida durante la carrera, particularmente en la asignatura de \textit{Sistemas Distribuidos}. Sin embargo, tras una primera fase de exploración, se migró la capa de presentación a \textbf{\textit{React}}, como se justifica en la sección 
\textit{\ref{sec:4.3_tecnologias} \nameref{sec:4.3_tecnologias}}.

La navegación entre las distintas secciones de la aplicación se gestiona mediante \textit{\textbf{React Router}}, permitiendo una experiencia de usuario fluida y sin recargas de página. Se han definido \textbf{rutas protegidas} para aquellas secciones que requieren autenticación o permisos específicos, utilizando el componente \texttt{ProtectedRoute}.

%---------------------------------------------------------------

\subsection{Arquitectura de componentes y experiencia de usuario}

%El objetivo de ofrecer una interfaz coherente y confiable se consiguió gracias a una estrategia basada en componentes reutilizables y un sistema de comunicación claro con el usuario. 

Para sentar las bases visuales y acelerar el desarrollo, se utilizó la biblioteca \textit{\textbf{Mantine}}. A diferencia de otros marcos de diseño rígidos, Mantine proporciona componentes de bajo nivel altamente \textbf{personalizables} y accesibles (como formularios o modales), lo que ha permitido diseñar una identidad visual propia sin renunciar a la robustez de elementos probados. Esta flexibilidad facilitó la creación de una interfaz limpia y responsiva, con soporte nativo para temas claros y oscuros. Sobre esta base de componentes customizados, se desarrollaron estructuras como \texttt{MainLayout}, que agrupa elementos comunes como la barra de navegación, y \texttt{FormLayout}, un esquema unificado para los formularios de creación y edición de todas las entidades.

Asimismo, para garantizar una experiencia consistente ante la naturaleza \textbf{asíncrona} de las peticiones a la API, la interfaz debe responder adecuadamente ante posibles demoras o errores. Por ello, se integró de forma sistemática un sistema de \textit{feedback} que informa al usuario en todo momento: \textbf{indicadores de carga} (\texttt{LoadingOverlay}) durante las operaciones, mensajes informativos cuando no hay datos para mostrar, alertas en formularios y notificaciones de éxito o error (mediante \textbf{\textit{\char`@{}mantine/notifications}}) con mensajes contextualizados. 

%---------------------------------------------------------------

\subsection{Gestión de datos y operaciones sobre entidades}

La gestión de las múltiples entidades del sistema se abordó mediante un patrón modular y repetible que \textbf{desacopla} la lógica de acceso a datos, la presentación en pantalla y la validación de la información introducida por el usuario.

La \textbf{comunicación con el \textit{backend}} se canaliza a través de un \textbf{cliente API centralizado}, que se encarga de realizar todas las peticiones HTTP a la API REST y gestionar de manera uniforme los errores y la autenticación. Para cada dominio, se crearon \textit{\textbf{hooks}} personalizados (por ejemplo, \texttt{useUsers}, \texttt{useProducts}) que encapsulan todas las operaciones CRUD, gestionando internamente los \textbf{estados} de carga, error y datos. Esta abstracción permitió que los componentes de UI se centraran exclusivamente en la presentación, consumiendo los \textit{hooks} sin preocuparse de los detalles de la comunicación.

Respecto a la gestión de \textbf{formularios}, se utilizó el sistema \texttt{useForm} de \textit{Mantine}, el cual permite definir validaciones personalizadas, gestionar el estado de los campos y mostrar mensajes de error de forma clara.

Para la \textbf{gestión del estado} general se siguió un principio de simplicidad: la mayoría de las entidades manejan su información de forma local mediante sus \textit{\textbf{hooks}}. Sin embargo, se hizo una excepción para el \textit{dashboard} de pedidos (figura \ref{fig:5.3_dashboard}), una de las funcionalidades centrales y más distintivas de la aplicación. Dado que este módulo requiere visualizar y actualizar en tiempo real el estado de los pedidos pendientes (permitiendo añadir productos, modificar cantidades y cambiar estados), se optó por un \textit{\textbf{store}} global basado en \textit{\textbf{Zustand}}. Esta decisión permite que varios componentes reaccionen simultáneamente a los cambios, ofreciendo una experiencia fluida y en tiempo real sin recargas de página.

\imagenConEtiqueta[0.8\textwidth]{img/apen_E/E_10_dashboard.png}{\textit{Dashboard} de pedidos}{5.3_dashboard}

\vspace{-1em}
\subsection{Internacionalización}

La aplicación es completamente multilingüe, permitiendo alternar entre español e inglés de forma instantánea. Para ello se ha utilizado \textbf{\textit{react-i18next}}, organizando los textos en archivos de recursos por módulo (\textit{namespaces}) y facilitando la traducción y ampliación futura a otros idiomas.

La aplicación también permite la búsqueda de alimentos de distintos idiomas y países. Como se ha indicado previamente, esto es gracias a que la API nutricional \textit{Open Food Facts} permite la búsqueda por texto libre, es decir, no requiere que se introduzca un índice exacto o un nombre de producto en un idioma particular, puesto que contiene información de miles de productos etiquetados de cada país.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Consumo de la API de datos nutricionales}
%Otro título: "Suministro de información nutricional mediante API"

La elección de una API que proporcionase información de alimentos y datos nutricionales se llevó a cabo mediante una comparativa que se encuentra detallada en el \textit{issue} \href{https://github.com/aperezolmos/Orderly/issues/10}{\#10}. La API seleccionada fue \textit{\textbf{Nutritionix}}~\cite{api:nutritionix}, la cual también fue elegida en el proyecto \textit{NutriMenu}~\cite{nutrimenu2024}.

Sin embargo, a 19 de noviembre de 2025, recibí una notificación oficial vía correo electrónico por parte de \textit{Nutritionix}, en la cual se comunicaba que el plan de acceso gratuito dejaría de estar operativo~\cite{reddit:nutritionixFreePlan}, invalidando así su uso para el proyecto.

Se optó entonces por la segunda opción más completa de la comparativa: \textbf{\textit{Open Food Facts} (\textit{OFF})}~\cite{api:openFoodFacts}. Esta decisión permitió la inclusión de métricas nutricionales (\textit{Nutri-Score} y clasificación NOVA) por alimento e información sobre \textbf{alérgenos}, las cuales no estaban disponibles en la mayoría de planes gratuitos del resto de APIs.

\imagenConEtiqueta[0.9\textwidth]{img/apen_E/E_13_5_alimentos_busquedaExterna.png}{Búsqueda de un alimento mediante la API \textit{Open Food Facts}}{5.3_alimentos_busquedaExterna}

La comunicación con \textit{OFF} se basa en una \textbf{primera fase} de búsqueda y selección de un alimento (figura \ref{fig:5.3_alimentos_busquedaExterna}), complementada por una \textbf{segunda fase} de petición de información detallada de dicho alimento y posterior adaptación al modelo de datos. Las peticiones a la API externa para ambas operaciones se realizan desde \textit{Spring Boot}. De esta manera, el \textit{frontend} queda \textbf{desacoplado} de la implementación de la API nutricional, favoreciendo el mantenimiento y el \textbf{intercambio} (o adición) de \textbf{fuentes de datos} nutricionales. También \textbf{se evitan restricciones de CORS} (\textit{Cross-Origin Resource Sharing}~\cite{mdn:cors}) al realizar las peticiones desde el servidor en lugar del cliente, garantizando la \textbf{compatibilidad entre navegadores} y centralizando la gestión de las cabeceras de red.

De igual manera, para facilitar el proceso de adaptación de los datos importados, las equivalencias entre campos del modelo y datos de \textit{OFF} se han centralizado en el archivo \texttt{OpenFoodFactsRegistry}, mientras que toda la lógica de conversión se sitúa en un \textit{mapper} específico (\texttt{OpenFoodFactsMapper}).

Dado que \textit{Open Food Facts} ofrece una cantidad muy elevada de información por alimento, fue necesario realizar un proceso de selección y adaptación de los campos más relevantes para el modelo de datos de la aplicación. Para cada nutriente, la API ofrece distintas representaciones (por ración o \textit{serving}, por 100 gramos...), lo que introduce cierta heterogeneidad en términos de disponibilidad y formato. Finalmente, se optó por utilizar de forma sistemática los valores normalizados por \textbf{100 gramos}, ya que estos presentan una mayor disponibilidad y fiabilidad al tratarse de información obligatoria en el etiquetado nutricional, según el Reglamento (UE) nº 1169/2011~\cite{reglamento1169_2011}. Esta elección permite simplificar el procesamiento de los datos, reducir la necesidad de conversiones y validaciones adicionales (por ejemplo, consultar las unidades), y resulta adecuada teniendo en cuenta que los valores nutricionales se \textbf{recalculan} posteriormente en función de la cantidad de alimento empleada en cada producto.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Evaluación automatizada de la calidad del código}

Para garantizar la robustez, mantenibilidad y calidad técnica de la solución desarrollada, se ha implementado un \textbf{flujo} de integración continua (CI) que automatiza el análisis del código fuente de forma integral. Esta infraestructura permite \textbf{monitorizar} de manera constante el estado del proyecto, asegurando que el desarrollo de nuevas funcionalidades no comprometa la integridad ni la calidad del software existente.

La implementación de este sistema se ha articulado mediante el uso de \textit{GitHub Actions} como \textbf{orquestador} de flujos de trabajo y \textit{SonarCloud} como plataforma de \textbf{análisis estático}. La configuración permite un análisis modular que abarca tanto el \textit{frontend} como el \textit{backend}, centralizando los resultados en un \textbf{único panel} de control.

Cada vez que se sincronizan \textbf{cambios} en el repositorio, se dispara automáticamente un proceso (\textit{workflow}) que prepara el entorno y realiza las siguientes acciones:
\begin{itemize}
	\item \textbf{En el \textit{backend}:} se compila la aplicación y se ejecuta la batería de \textbf{pruebas} unitarias y de integración mediante \textit{Maven}. Durante este proceso, se utiliza el componente \textit{JaCoCo} para generar informes de \textbf{cobertura} de código, que son enviados a \textit{SonarCloud} para su evaluación.
	\item \textbf{En el \textit{frontend}}: aunque esta parte no dispone actualmente de pruebas automatizadas, se integra en el flujo de análisis para evaluar la calidad del código escrito, detectando malas prácticas o posibles errores de lógica en JavaScript/\textit{React}.
\end{itemize}

La principal ganancia de este enfoque es la obtención de un \textit{``Quality Gate''} o \textbf{umbral de calidad}. Con cada subida de código, el sistema evalúa automáticamente la presencia de errores, vulnerabilidades, duplicidades y ``deuda técnica'' (\textit{code smells}). Esto permite una detección temprana de problemas que, de otra forma, podrían pasar desapercibidos hasta etapas más avanzadas del despliegue.

\todo[inline]{redactar acerca de cómo se ha quitado la cobertura para pasar el quality gate}

\missingfigure{metricas proyecto sonarcloud}

%En la figura \todo{\ref{fig:sonarcloud_metrics}} se muestra el panel de métricas obtenido tras el análisis de la aplicación. En él se puede observar cómo el sistema califica distintos aspectos del software, ofreciendo una visión objetiva y cuantitativa de la salud técnica del proyecto, destacando la ausencia de vulnerabilidades críticas y el cumplimiento de los estándares de desarrollo propuestos.\todo{modificar}
%
%\todo[inline]{redactar acerca de cómo se puede navegar por cada módulo y ver las métricas exactas. por ejemplo la cobertura puede poner un 26\% general pero si entras en spring boot se ve que realmente es del 56}
